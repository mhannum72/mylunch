{
  "name": "stackvis",
  "version": "0.1.0",
  "description": "stack visualization tools",
  "main": "./lib/stackvis.js",
  "bin": {
    "flamegraph": "./cmd/flamegraph",
    "stackcollapse": "./cmd/stackcollapse",
    "stackcollapse-perf": "./cmd/stackcollapse-perf",
    "stackcollapse-stap": "./cmd/stackcollapse-stap",
    "stackvis": "./cmd/stackvis"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/davepacheco/node-stackvis.git"
  },
  "dependencies": {
    "bunyan": "0.16.7",
    "carrier": "0.1.7"
  },
  "readme": "# node-stackvis\n\nStackvis is a JavaScript library for visualizing call stacks.  For an example\nof the kind of data we're talking about, see:\n\n    http://www.cs.brown.edu/~dap/redis-flamegraph.svg\n\nThis library is based heavily on Brendan Gregg's\n[FlameGraph](http://github.com/brendangregg/FlameGraph/) tools.\n\n\n## Command-line tools\n\nThis module provides \"stackcollapse\", and \"flamegraph\", which are essentially\ndirect ports of the original FlameGraph tools.  You can use them by first\ncollecting data:\n\n    # dtrace -o dtrace.out -n 'profile-97{ @[ustack()] = count(); }' \\\n                           -n 'tick-30s{ exit(0); }'\n\nthen collapse common stacks:\n\n    # stackcollapse < dtrace.out > collapsed.out\n\nthen create a flame graph:\n\n    # flamegraph < collapsed.out > graph.svg\n\nSee the above link for an example.\n\n\n## API\n\nThe command-line tools are thin wrappers around the API, which is built upon a\nsimple internal representation of stack traces and a bunch of Readers\n(lib/input-\\*.json) and Writers (lib/output-\\*.json) for various intermediate\nformats:\n\n- input-dtrace.js: reads stacks from the output of a DTrace profiling script\n- input-collapsed.js: reads data in the form used by the \"stackcollapse\" tool,\n  where function offsets are stripped out, common stacks are collapsed, and\n  there's one stack per line.\n- output-collapsed.js: writes stacks in above \"collapsed\" form\n- output-flamegraph-svg.js: writes stacks as a flame graph SVG\n\nClient code shouldn't load these directly.  Instead, require 'stackvis' and use\nlookupReader and lookupWriter:\n\n    var mod_stackvis = require('stackvis');\n    var dtrace_reader = mod_stackvis.lookupReader('dtrace')\n    var collapsed_writer = mod_stackvis.lookupWriter('collapsed');\n\nThe main operation is translating from one representation to another (e.g.,\nDTrace output to a flame graph) using pipeStacks() (which requires a Bunyan\nlogger):\n\n    var mod_bunyan = require('bunyan');\n    var log = new mod_bunyan({ 'name': 'mytool', 'stream': process.stderr });\n    mod_stackvis.pipeStacks(log, process.stdin, dtrace_reader, collapsed_writer,\n        process.stdout, function () { console.error('translation finished'); });\n\nThis example instantiates a new dtrace_reader to read DTrace output from\nprocess.stdin and then emits the result in collapsed form to process.stdout\nthrough the collapsed_writer.\n\n## Adding new readers and writers\n\nIt's easy to add new readers (for new input sources) and writers (for new types\nof visualizations).  See lib/stackvis.js for an overview of how these interfaces\nwork.\n\n## TODO\n\n- See about dealing with multiple \"silos\" of a single flame graph that are\n  essentially the same, but differ in exactly one frame.\n- Experiment with flame graph coloring.  Current options include random,\n  gradient, and time-based.  Another possibility is to use hue to denote the\n  module and saturation to denote the size of a frame relative to others at the\n  same level of depth.\n- Experiment with more interactive visualizations, like\n  http://bl.ocks.org/1005873\n",
  "readmeFilename": "README.md",
  "_id": "stackvis@0.1.0",
  "dist": {
    "shasum": "c8f407633db80a1db2ba6248e575bd972ff69180"
  },
  "_from": "stackvis"
}
